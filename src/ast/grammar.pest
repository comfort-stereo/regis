WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

ignored = _{ COMMENT | (" " | "\n" | "\t" | "\r") }

eoi = _{ !ANY }
br = _{ ("\n" | "\r")+ }

keyword_fn = _{ "fn" }
keyword_let = _{ "let" }
keyword_echo = _{ "echo" }
keyword_null = _{ "null" }
keyword_if = _{ "if" }
keyword_else = _{ "else" }
keyword_true = _{ "true" }
keyword_false = _{ "false" }
keyword_loop = _{ "loop" }
keyword_while = _{ "while" }
keyword_return = _{ "return" }
keyword_break = _{ "break" }
keyword_continue = _{ "continue" }

keyword = _{
      keyword_fn
    | keyword_let
    | keyword_echo
    | keyword_null
    | keyword_if
    | keyword_else
    | keyword_true
    | keyword_false
    | keyword_loop
    | keyword_while
    | keyword_return
    | keyword_break
    | keyword_continue
}

identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

null = @{ keyword_null }
boolean = @{ keyword_true | keyword_false }
int = @{ "-"? ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
float = @{ int ~ "." ~ ASCII_DIGIT+ }
variable = { identifier }

string = ${ "\"" ~ chars ~ "\"" }
chars = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ (ASCII_HEX_DIGIT{4} | ("{" ~ ASCII_HEX_DIGIT+ ~ "}")))
}

atom = _{
      null
    | boolean
    | float
    | int
    | string
    | variable
}

wrapped = { "(" ~ br? ~ expression ~ br? ~ ")" }

list = { "[" ~ br? ~ (expression ~ br? ~ "," ~ br?)* ~ expression? ~ br? ~ "]" }

object = { "{" ~ br? ~ (pair ~ br? ~ "," ~ br?)* ~ pair? ~ br? ~ "}" }
pair = { key ~ br? ~ ":" ~ br? ~ expression }
key = _{ identifier | string | key_expression }
key_expression = { "[" ~ br? ~ expression ~ br? ~ "]" }

function = {
    keyword_fn
    ~ br? ~ (identifier? ~ br? ~ "(" ~ br? ~ parameters ~ br? ~ ")")?
    ~ br? ~ (block | ("=>" ~ br? ~ expression))
}
parameters = { (identifier ~ br? ~ "," ~ br?)* ~ identifier? ~ br? }
arguments = { (expression ~ br? ~ "," ~ br?)* ~ expression? ~ br? }

operator_binary_ncl = { "??" }
operator_binary_mul = { "*" }
operator_binary_div = { "/" }
operator_binary_add = { "+" }
operator_binary_sub = { "-" }
operator_binary_gt = { ">" }
operator_binary_lt = { "<" }
operator_binary_gte = { ">=" }
operator_binary_lte = { "<=" }
operator_binary_eq = { "==" }
operator_binary_neq = { "!=" }
operator_binary_and = { "&&" }
operator_binary_or = { "||" }

operator_assign_direct = { "=" }
operator_assign_ncl = { "??=" }
operator_assign_mul = { "*=" }
operator_assign_div = { "/=" }
operator_assign_add = { "+=" }
operator_assign_sub = { "-=" }
operator_assign_and = { "&&=" }
operator_assign_or = { "||=" }

binary_operator = _{
      operator_binary_ncl
    | operator_binary_mul
    | operator_binary_div
    | operator_binary_add
    | operator_binary_sub
    | operator_binary_gte
    | operator_binary_lte
    | operator_binary_gt
    | operator_binary_lt
    | operator_binary_eq
    | operator_binary_neq
    | operator_binary_and
    | operator_binary_or
}

assignment_operator = _{
      operator_assign_direct
    | operator_assign_ncl
    | operator_assign_mul
    | operator_assign_div
    | operator_assign_add
    | operator_assign_sub
    | operator_assign_and
    | operator_assign_or
}

binary_operations = {
    binary_operable_expression ~ br? ~ (binary_operator ~ br? ~ binary_operable_expression)+
}

index = { "[" ~ br? ~ expression ~ br? ~ "]" }
dot = { "." ~ br? ~ identifier }
call = { "(" ~ br? ~ arguments ~ br? ~ ")" }

chain = {
    chainable_expression ~ (index | dot | call)+
}

binary_operable_expression = _{
      wrapped
    | chain
    | function
    | list
    | object
    | atom
}

chainable_expression = _{
      wrapped
    | function
    | list
    | object
    | atom
}

expression = _{
      wrapped
    | binary_operations
    | chain
    | function
    | list
    | object
    | atom
}

return_statement = {
      keyword_return ~ br? ~ expression
    | keyword_return
}

break_statement = { keyword_break }
continue_statement = { keyword_continue }
echo_statement = { keyword_echo ~ br? ~ expression }
function_statement = { function }
variable_declaration_statement = { keyword_let ~ br? ~ identifier ~ br? ~ "=" ~ br? ~ expression }
variable_assignment_statement = { identifier ~ br? ~ assignment_operator ~ br? ~ expression }
chain_assignment_statement = { chain ~ br? ~ assignment_operator ~ br? ~ expression }
push_statement = { expression ~ br? ~ "[]" ~ br? ~ "=" ~ br? ~ expression }
expression_statement = { expression }

execution_statement = _{
      return_statement
    | break_statement
    | continue_statement
    | echo_statement
    | function_statement
    | variable_declaration_statement
    | variable_assignment_statement
    | chain_assignment_statement
    | push_statement
    | expression_statement
}

block = { "{" ~ br? ~ statement* ~ br? ~ "}" }

if_statement = { keyword_if ~ br? ~ expression ~ br? ~ block ~ br? ~ else_statement? }
else_statement = { keyword_else ~ br? ~ (block | if_statement) }
loop_statement = { keyword_loop ~ br? ~ block }
while_statement = { keyword_while ~ br? ~ expression ~ br? ~ block }

block_statement = _{
      if_statement
    | else_statement
    | loop_statement
    | while_statement
}

terminator = _{ ";" | &"}" | br | eoi }

statement = _{
    br?
    ~ (
          block_statement
        | (execution_statement ~ terminator)
    )
    ~ br?
}

//
// Root
//

module = { SOI ~ ignored* ~ statement* ~ ignored* ~ eoi }
